<refentry id="{@id}">
 <refnamediv>
    <refname>ccHost - Developer Cookbook</refname>
    <refpurpose>A (hopefully) simple breakdown of common operations.</refpurpose>
 </refnamediv>
 {@toc}

<refsect1 id="{@id readme}">
<title>Read Me First</title>
  <para>
      This document is a continuation of the {@tutorial admin.pkg}. If nothing else you 
      need to familiarize yourself with {@tutorial admin.files.pkg} and {@tutorial admin.query.pkg}. If you 
      need to do anything more than the most rudimentary XHTML output then you also need know the material 
      in {@tutorial admin.advanced.xhtml.pkg} and {@tutorial admin.skins.pkg} 
  </para>
  <para>
      <note>While it is tempting to dig around in ccHost code to cut/paste out pieces
      there are many places that today would be considered, er, less than 'best practices.' By
      reading this document you can at least begin to recognize what is supposed to be happening
      in some of the 'older' code.
      </note>
  </para>
  <refsect2 id="{@id dirstruct}">
  <title>Directory Structure</title>
       <para>
          <warning>Each ccHost installation has a set of system directories that start with <filename>cc</filename>
          prefix. You should only ever touch the <filename>cc*</filename> directories in dire emergencies.</warning>
       </para>
       <para>
          Your installation has a set of directories where the system will look for custom code,
          XHTML templates, log files, temp files, etc. Before starting work on customizing your site, go to
          <command>Global Settings</command> then <command>Paths</command> and take a look around. When this
          document refers to your <filename>viewfile Path</filename>, <filename>Plugins Path</filename>, etc.
          it means the values in the <command>Paths</command> admin screen (aka user directories).
      </para>
      <para>
          How files are found:
      </para>
      <orderedlist class="tutlist">
          <listitem>
            When looking for specific files, the default behavoir is that user directories are searched 
            in the order specified in the <command>Paths</command> admin screen. The first matching filename will 
            be used. Subdirectories are <emphasis>not</emphasis> searched with one exception mentioned
            below.
          </listitem>
          <listitem>
            Any file with a <filename>.php</filename> extension (aka module) anywhere in 
            the <command>Plugins Path</command> will be loaded each and every page (or AJAX) request. 
            The ordre of directories in <command>Plugins Path</command> will be honored, but actual 
            the actual order the files are loaded within each directory is system dependent so you 
            should not assume an order.
            <para>
              <note>
                  Running code at the top of the module is officially a Bad Idea. You should wait
                  for the {@link CC_EVENT_APP_INIT} event to occur 
                  before even thinking about executing custom code.
              </note>
            </para>
          </listitem>
          <listitem>
            The <filename>.php</filename> files in the system directory <filename>ccextras</filename> will is  
            loaded first, then the <command>Plugins Path</command> user directores.
          </listitem>
          <listitem>
            The <filename>viewfile</filename> (alias <filename>docs</filename>) command uses 
            <filename>viewfile Paths</filename> to search for the requested document. If the requested
            file is not found, the system will try again with an <filename>.xml</filename> extension
            (assuming the request had no extension). So the following requests will all yeild the same
            result:
            <example><literal><uri>http://your_install/media/docs/query</uri>              
<uri>http://your_install/media/docs/query.xml</uri>
<uri>http://your_install/media/viewfile/query</uri>
<uri>http://your_install/media/viewfile/query.xml</uri>
            </literal></example>
          </listitem>
          <listitem>
            When looking for a template from PHP code the <command>Skins Path</command> user directories are
            searched in the order specified by the user. However, when a template is referenced from 
            <emphasis>within another template</emphasis>, the directory of the calling template will be 
            searched first, then, if not found, the user directories.
          </listitem>
          <listitem>
              For the <emphasis>template</emphasis> (<emphasis>t</emphasis>) parameter of a Query
              request, the <filename>Skins Path</filename> is searched in order, adding a <filename>.xml</filename>
              extension if needed. If not found an additional search of subdirectories specifically
              called "<filename>formats</filename>" will be used.
          </listitem>
      </orderedlist>
   </refsect2>
</refsect1>

<refsect1 id="{@id debug}">
<title>Develepment Environment</title>

    <refsect2 id="{@id enable}">
    <title>Enabling Debug Mode</title>

      <para>
          In order to enable debugging on a development non-production machine, put
          the following code into a module in your <filename>Plugins Path</filename>:
      </para>
      <programlisting role="php"><![CDATA[<?  CCDebug::Enable(true); ?>]]></programlisting>

    </refsect2>

    <refsect2 id="{@id inspect}">
    <title>Inspecting Variables</title>

        <para>
            With debugging enabled, you can inspect any variable on the screen using {@link CCDebug::PrintVar} or in the log using 
            {@link CCDebug::LogVar} or send any message to the log using {@link CCDebug::Log}.
        </para>
        <para>
            {@link CCDebug::PrintVar} will stop execution at the point
            it is called and display the variable in the browser. You can not pass a
            constant, it must be a variable (or object or array, etc.) that can be a PHP reference.
        </para>
        <para>
            <note>HINT: If you want to inspect more than one variable at a time, put them into an array.</note>
        </para>

<programlisting role="php"><![CDATA[  

// Some examples of 
function foo()
{
    CCDebug::PrintVar($_POST);
}

function bar()
{
    global $CC_GLOBALS;

    CCDebug::PrintVar($CC_GLOBALS);
}

function some_method_1($arg1, $arg2, $arg3 )
{
    // this will execute in any mode
    $value1 = $arg1 + 10;    

    // this will only work in debug mode
    CCDebug::PrintVar($value1);  

    // this will not execute in debug mode
    $value2 = $arg2 - 10;    
}

function some_method_2($arg1, $arg2, $arg3 )
{
    $x[] = $arg1;
    $x[] = $arg2;
    CCDebug::PrintVar($x);
}

function some_method_2($arg1 )
{
    // This won't work, the var must be a reference
    CCDebug::PrintVar('some arg: ' . $arg1);

    // this is fine
    $x = 'some arg: ' . $arg1;
    CCDebug::PrintVar($x);
}

function called_from_template($arg1)
{
    // if you are debugging code that is part of the
    // template display or called from a PHPTAL
    // template then you must specify
    // that the call is "not template safe"

    CCDebug::PrintVar($arg1, false);
}
 ]]></programlisting>

    <para>
        {@link CCDebug::LogVar} and {@link CCDebug::Log} will continue execution passed the point they are 
        called and put the result into the log. (The log file is called <filename>cc-log.txt</filename>
        in <filename>Logfile Directory</filename>.)
    </para>

<programlisting role="php"><![CDATA[  function some_method_1($arg1, $arg2, $arg3 )
{
    // code will execute
    $value1 = $arg1 + 10; 

    CCDebug::LogVar('this is the value:', $value1);

    // so will this
    $value2 = $arg2 - 10; 
}

function some_method_2($arg1, $arg2, $arg3 )
{
    // code will execute
    $value1 = $arg1 + 10; 

    CCDebug::Log("I'm here at line " . __LINE__ );

    // so will this
    $value2 = $arg2 - 10; 
} ]]></programlisting>

    </refsect2>

    <refsect2 id="{@id stacktrace}">
    <title>Displaying a Stack Trace</title>

        <para>
          There's a lot of common code in ccHost and sometimes it's difficult
          to figure out who is calling what in what context. If you're seeing an
          error in common code make sure to 
          ({@tutorial cchost.pkg#debug.enable turn on debug mode})
          and insert the following line where the error is occurring:
        </para>
        <programlisting role="php"><![CDATA[  CCDebug::StackTrace(); ]]></programlisting>

      </refsect2>

    <refsect2 id="{@id testbed}">
    <title>Create a Quick Test Bed</title>

      <para>
        Sometimes you just want to see if your idea will work at all. To create a quick
        and dirty test bed start by {@tutorial cchost.pkg#modules.create creating a module} with
        this code.
      </para>
      <programlisting role="php"><![CDATA[  CCEvents::AddHandler(CC_EVENT_APP_INIT,  'just_testing' );

function just_testing()
{
    if( empty($_GET['test']) || !CCUser::IsAdmin()))
        return;

     // your code here....

} ]]></programlisting>


        <para>To invoke your test bed browse to: <uri>http://your_cchost_install/?test=1</uri></para>

      </refsect2>

</refsect1> <!-- end DEBUG ENV -->

<refsect1 id="{@id modules}">
<title>Code Modules</title>

      <refsect2 id="{@id create}">
      <title>Create a New Module</title>

        <para>
            Create any file with <filename>.php</filename> extension and put it into <filename>Plugins 
            Path</filename>. You're done.
        </para>

      </refsect2>


      <refsect2 id="{@id url}">
      <title>Create a URL and Bind it to a Method</title>

<programlisting role="php"><![CDATA[  // Tell ccHost you have a URL to map:
CCEvents::AddHandler( CC_EVENT_MAP_URLS, 
                      array( 'myclass', 'OnMapUrls' ) );

class myclass
{
  function OnMapUrls()
  {

    // this will be called when ccHost needs to know about
    // url mappings, it is only called when an admin does
    // updates with ?update=1 
    //
     CCEvents::MapUrl( ccp('some', 'url'),
             array( 'myclass', 'some_url_handler') ,
             CC_MUST_BE_LOGGED_IN
            );
  }

  // this is your custom code that will be called
  // when someone browses to some/url
  //
  function some_url_handler($required, $optional='')
  {
     // some random code:
     CCPage::SetTitle('Hello $required!');
     if( empty($optional) )
       CCPage::Prompt("hello world!");
     else
       CCPage::Prompt("hello $optional!");
  }

}
 ]]></programlisting>

      <para>The last parameter is an access flag that must be one of the following:</para>

<programlisting role="php"><![CDATA[  CC_MUST_BE_LOGGED_IN
CC_ONLY_NOT_LOGGED_IN
CC_DONT_CARE_LOGGED_IN
CC_ADMIN_ONLY
 ]]></programlisting>

        <para>
            To register the new binding browse to: <uri>http://example.com/?update=1</uri>. To see this action 
            you can call any of the following urls:
        </para>

<example><literal><uri>http://example.com/media/some/url/cchost</uri>
<uri>http://example.com/media/some/url/cchost/mom</uri>
<uri>http://example.com/media/some/url/goodbye/marvin</uri></literal></example>

    </refsect2>
</refsect1>   <!-- END OF Modules -->

<refsect1 id="{@id datab}">
<title>Database</title>

    <refsect2 id="{@id newcol}">
    <title>Create a New Database Column</title>

    <para>Here are the steps to add a new database column into an existing ccHost table.</para>
    <para>First: create a file whose name is in the format: update_unique_part.inc and put that into ccextras directory.</para>
    <para>For the unique_part you should use something that identifies you and a version number:</para>

<programlisting role="php"><![CDATA[  ccextras/update_joesoft_v_1_0.inc
ccextras/update_janeplugins_v_3_2a.inc ]]></programlisting>
<para>In that module create a class derived from CCUpdate
and implement the Update method that is named exactly the
same name as the unique_part of the file name:</para>
<programlisting role="php"><![CDATA[  // columns required by joesoft 

class joesoft_v_1_0 extends CCUpdate
{
    function Update()
    {
    }
} ]]></programlisting>

          <para>Next you want to call the inherited _check_for_field() method. The prototype is:</para>

<programlisting role="php"><![CDATA[  function _check_for_field( $table_name,
                                 $column_name,
                                 $column_description ) ]]></programlisting>

          <para>Let's say you want to add an column for 'age' to the users table:</para>

<programlisting role="php"><![CDATA[  // columns required by joesoft 

class joesoft_v_1_0 extends CCUpdate
{
    function Update()
    {
        $this->_check_for_field(
                        'cc_tbl_user', 
                        'user_age', 
                        'INT(4) unsigned');
    }
} ]]></programlisting>

          <para>When someone installs your plugin they will have to (logged in as admin) update
          their site by browsing to: <uri>http://cchost_installation/?update=1</uri></para>

    </refsect2>

    <refsect2 id="{@id newtable}">
    <title>Create a New Database Table</title>

        <para>
            To add an entirely new table to a ccHost installation follow the same steps to 
            Create a New Database Column ({@tutorial cchost.pkg#datab.newcol}) 
            except for the code in Update which will look something like this:
        </para>

<programlisting role="php"><![CDATA[  // table required by joesoft 

class joesoft_v_1_0 extends CCUpdate
{
  function Update()
  {
   $sql = '
    CREATE TABLE joes_table
    (
      jt_id    int(11) unsigned  NOT NULL auto_increment,
      jt_user  int(11) unsigned  NOT NULL,
      jt_age   int(4)  unsigned  NOT NULL,
      jt_allow_im  int(2)  unsigned  NOT NULL,
      jt_im    varchar(4) NOT NULL,
      jt_location  varchar(255) NOT NULL,

      PRIMARY KEY jt_id (jt_id)
    )
    ';

    CCDatabase::Query($sql);
  }
} ]]></programlisting>

        <para>
            It is strongly suggested that you create a ccHost table wrapper for the class. After you
            create a new module ({@tutorial cchost.pkg#modules.create}) 
            you should create a class derived from CCTable:
        </para>


<programlisting role="php"><![CDATA[  class JSJoesTable extends CCTable
{
  function JSJoesTable()
  {
     $this->CCTable( 'joes_table',  // mysql table name
             'jt_id'   // PRIMARY KEY
           );

  }

  // create a singleton factory
  function & GetTable()
  {
    static $_table;
    if( empty($_table) )
      $_table = new JSJoesTable();
    return $_table;
  }
} ]]></programlisting>

      </refsect2>


    <refsect2 id="{@id insert}">
    <title>Insert a Record Into a Table</title>

        <para>All tables in the system follow the same code pattern for row insertion:</para>

<programlisting role="php"><![CDATA[  function AddUserAge($user_id, $age)
{
    $joestable =& JSJoesTable::GetTable();
    $args['jt_user'] = $user_id;
    $args['jt_age'] = $age;
    $joestable->Insert($args);
} ]]></programlisting>

        <para>If you need to know the key of the new record use NextID:</para>

<programlisting role="php"><![CDATA[  function AddUserAge($user_id, $age)
{
    $joestable =& JSJoesTable::GetTable();
    $args['jt_id'] = $joestable->NextID();
    $args['jt_user'] = $user_id;
    $args['jt_age'] = $age;
    $joestable->Insert($args);
    return $args['jt_id'];
} ]]></programlisting>

    </refsect2>


    <refsect2 id="{@id update}">
    <title>Update a Database Record</title>

        <para>
            All tables in the system follow the same code pattern for row updating. The
            Update assumes that the argument array contains
            a primary key (aka 'id') value:
        </para>

<programlisting role="php"><![CDATA[  function UpdateAge($jt_id, $age)
{
    $joestable =& JSJoesTable::GetTable();
    $args['jt_id'] = $jt_id;
    $args['jt_age'] = $age;
    $joestable->Update($args);
} ]]></programlisting>

        <para>If you don't have the key you'll need to look it up:</para>

<programlisting role="php"><![CDATA[  function UpdateUserAge($user_id, $age)
{
    $joestable =& JSJoesTable::GetTable();
    $where['jt_user'] = $user_id;
    $jt_id = $joestable->QueryKey($where);
    UpdateAge($jt_id, $age);
}

function UpdateAge($jt_id, $age)
{
    $joestable =& JSJoesTable::GetTable();
    $args['jt_id'] = $jt_id;
    $args['jt_age'] = $age;
    $joestable->Update($args);
}
 ]]></programlisting>

        </refsect2>

        <refsect2 id="{@id uploadextra}">
        <title>Adding Custom Data To Upload Records</title>

            <para>
              You can add custom data to any upload record without changing the database meta data (adding
              tables or columns). The upload_extra field in each upload record ({@tutorial cchost.pkg#termstuff.rowvsrecord}) 
              designed specifically to hold this kind of custom data. There is also a simple API for 
              setting and getting your data.
            </para>

<h3>To Add Your Custom Data</h3>
<programlisting role="php"><![CDATA[  function add_my_data($my_data,$upload_id)
{
  $uploads =& CCUploads::GetTable();
  $uploads->SetExtraField(
     $upload_id,    // This can also be a reference
                    // to a record  
     'joes_extra',  // The name of your extra field  
     $my_data       // This can be any serializeable type
                    // of data including array.
   );
} ]]></programlisting>

<h3>To Retrieve Your Custom Data</h3>
<programlisting role="php"><![CDATA[  function get_my_data($upload_id)
{
  $uploads =& CCUploads::GetTable();
  return $uploads->GetExtraField($upload_id, 'joes_extra');
} ]]></programlisting>

<para>Alternatively, if you are already looking at a record, you can access the data directly:</para>
<programlisting role="php"><![CDATA[  function get_my_data_from_record(&$record)
{
  if( exist( $record['upload_extra']['joes_extra'] ) )
     return $record['upload_extra']['joes_extra'];
  return null;
} ]]></programlisting>

<h3>To Search For Your Custom Data</h3>
<para>The only drawback to using this method is that searching for your data is extremely expensive
(it takes a long time) and is strongly recommended you don't do it. See the documentation for
CCUploads::WhereForSerializedField if you really must or if
searching on this data is critical then you should probably consider adding a 
new column ({@tutorial cchost.pkg#datab.newcol}) to cc_tbl_uploads or even better, a 
new table ({@tutorial cchost.pkg#datab.newtable}) instead using 
the extra field.</para>
<para>If you can get by with just searching for records with presence of your extra
data then you can add a system tag to the upload row when you add the data:</para>
<programlisting role="php"><![CDATA[  function add_my_data($my_data,$upload_id)
{
  $uploads =& CCUploads::GetTable();
  $uploads->SetExtraField($upload_id,
                          'joes_extra',
                          $my_data
                          );

  // A terrible name for a useful function:
  // this call will add a tag 'joes_data'
  CCUploadAPI::UpdateCCUD($upload_id,'joes_tag','');

} ]]></programlisting>
<para>Now it's just a matter of setting a tag filter to limit results that have your custom
data in the extra fields:</para>
<programlisting role="php"><![CDATA[  function list_recs_with_joes_data()
{
  $uploads =& CCUploads::GetTable();

  // Filter results with this tag
  $uploads->SetTagFilter('joes_tag');    
  
  // Empty 'where' gets all tagged records
  $records =& $uploads->GetRecords(''); 
  
  // Don't forget to release the tag filter (!!!)
  $uploads->SetTagFilter('');            
  
  // $records now points to all uploads with our data
  $count = count($records);              
  for( $i = 0; $i < $count; $i++)
  {
    $record =& $records[$i];
    $joes_data = $record['upload_extra']['joes_data'];
    //.... ]]></programlisting>
<h3>Editing and Deleting Your Custom Data</h3>
<para>Editing and deleting the data has some non-obvious implications whether you use
the tagging method above or not. This method puts some of the basics together:</para>
<programlisting role="php"><![CDATA[  function update_extra_data($upload_id, $my_data)
{
  $uploads =& CCUploads::GetTable();

  // let's see what's currently there: 

  $current_data = $uploads->GetExtraField($upload_id,'joes_data');

  if( empty($my_data) )
  {
    // delete the tag:

    CCUploadAPI::UpdateCCUD($upload_id,'','joes_tag');

    if( !empty($current_data) )
    {
      // something is there now, let's clear it:

      $uploads->SetExtraField($upload_id,'joes_data','');
    }
  }
  else
  {
    // do we need to add a tag? 

    if( empty($current_data) )
      CCUploadAPI::UpdateCCUD($upload_id,'joes_tag','');  // yup

    // set the extra data 
    $uploads->SetExtraField($upload_id,'joes_data',$my_data);

  }
} ]]></programlisting>
</refsect2>

</refsect1> <!-------- END OF Database ---------->

<refsect1 id="{@id form}">
<title>Forms</title>

 <refsect2 id="{@id newform}">
<title>Display a Form</title>

<para>Create a class that derives that from CCForm. The name
of the class must in this specific form:</para>
<programlisting role="php"><![CDATA[  2-letter-prefix form_name Form (no spaces)

class CCJoesEditForm extends CCForm  // this is ok
class xxEditAgeForm  extends CCForm  // this is ok

class Joe   extends CCForm           // this is not
class xxJoe extends CCForm           // this is not ]]></programlisting>
<para>Fields are created in the constructor of the form object:</para>
<programlisting role="php"><![CDATA[  class JSJoesEditForm extends CCForm
{
  function JSJoesEditForm()
  {
    $this->CCForm();

    $fields = array(
       'age' => array(
          'label'   => 'Age',
          'form_tip'  => 'Enter your age here',
          'formatter' => 'textedit',
          'flags'   => CCFF_REQUIRED,
          ),
       'allow_im' => array(
          'label'   => 'Enable Instant Messaging',
          'form_tip'  => 'Enable instant messages notifications',
          'formatter' => 'checkbox',
          'flags'   => CCFF_NONE,
          ),
       'im' => array(
          'label'   => 'IM Service',
          'formatter' => 'select',
          'options'   => array(
                   'aol' => 'Americal Online',
                   'msn' => 'Microsoft',
                   'irc' => 'Independent Relay Crisis'
                   ),
          'flags'   => CCFF_NONE,
          ),
      );

    $this->AddFormFields($fields);
  }
} ]]></programlisting>
<para>A 'formatter' is the thing that generates the html for the field and
validates the value during submit. There are many standard and built in
generators. See cclib/cc-form.php for a list
functions that start with generator_ for the
standard ones. </para>
<para>The 'flags' field is very important and can lead to a lot of confusion
if used incorrectly. See the documentation AddFormFields
in cclib/cc-form.php for what is possible. All
flags begin with CCFF_ prefix.</para>
<para>To display your form:</para>
<programlisting role="php"><![CDATA[  function EditJSInfo()
{
    CCPage::SetTitle('Edit Special User Info');

    $form = new JSJoesEditForm();

    CCPage::AddForm( $form->GenerateForm() );
} ]]></programlisting>


</refsect2>



 <refsect2 id="{@id prepop}">
<title>Populate a Form</title>

<para>There are several ways to populate a form you've created ({@tutorial cchost.pkg#form.newform}). By
far the most efficient way is to use PopulateValues. In
order for PopulateValues to work you first have to mark
the fields you expect to populate with CCFF_POPULATE flag</para>
<programlisting role="php"><![CDATA[  'age' => array(
        'label'     => 'Age',
        'form_tip'  => 'Enter your age here',
        'formatter' => 'textedit',
        'flags'     => CCFF_REQUIRED | CCFF_POPULATE,
        ),
'allow_im' => array(
        'label'     => 'Enable Instant Messagings',
        'formatter' => 'checkbox',
        'flags'     => CCFF_POPULATE,
        ),
'im' => array(
    'label'     => 'IM Service',
    'formatter' => 'select',
    'options'   => array(
                     'aol' => 'Americal Online',
                     'msn' => 'Microsoft',
                     'irc' => 'Independent Relay Crisis'
                     ),
    'flags'     => CCFF_POPULATE,
    ),
 ]]></programlisting>
<para>Now you're ready to populate:</para>
<programlisting role="php"><![CDATA[  function EditJSInfo($age, $allow_im, $im )
{
    CCPage::SetTitle('Edit Special User Info');

    $form = new JSJoesEditForm();

    $values['age'] = $age;
    $values['allow_im'] = $allow_im;
    $values['im'] = $im;
    $form->PopulateValues($values);

    CCPage::AddForm( $form->GenerateForm() );
} ]]></programlisting>

<para>
HINT: If you are populating values from 
a database row ({@tutorial cchost.pkg#datab.newtable}), then your life will get much
simpler if name the fields the same as the database columns:</para>
<programlisting role="php"><![CDATA[  class JSJoesEditForm extends CCForm
{
  function JSJoesEditForm()
  {
  $this->CCForm();

  $fields = array(
     'jt_age' => array(
      'label'   => 'Age',
      'form_tip'  => 'Enter your age here',
      'formatter' => 'textedit',
      'flags'   => CCFF_REQUIRED | CCFF_POPULATE,
      ),
     'jt_allow_im' => array(
      'label'   => 'Enable Instant Messagings',
      'formatter' => 'checkbox',
      'flags'   => CCFF_POPULATE,
      ),
     'jt_im' => array(
      'label'   => 'IM Service',
      'formatter' => 'select',
      'options'   => array(
           'aol' => 'Americal Online',
           'msn' => 'Microsoft',
           'irc' => 'Independent Relay Crisis'
           ),
      'flags'   => CCFF_POPULATE,
      ),
    );

  $this->AddFormFields($fields);
  }
} ]]></programlisting>

<para>Now the results of doing a query for a row can be used directly to populate the
form:</para>
<programlisting role="php"><![CDATA[  function EditJSInfo($jt_id )
{
    CCPage::SetTitle('Edit Special User Info');

    $form = new JSJoesEditForm();

    $joestable =& JSJoesTable::GetTable();
    $values = $joestable->QueryKeyRow($jt_id);
    $form->PopulateValues($values);

    CCPage::AddForm( $form->GenerateForm() );
} ]]></programlisting>

</refsect2>


 <refsect2 id="{@id submit}">
<title>Handling Form Submit</title>

<para>To handle a user submit of a form you've created ({@tutorial cchost.pkg#form.newform}) we'll
use the same method we use to populate the form ({@tutorial cchost.pkg#form.prepop}), only now
we'll check if we are processing the submit.</para>
<para>You can use the same URL to display the form initially and handle the
submit by mapping one URL ({@tutorial cchost.pkg#modules.url}) to this method.</para>
<para>For (marginal) security reasons, the name of the form in lower case is in
PHP's $_POST array so you want to check for that to
see if you are in fact, process the submit:</para>
<programlisting role="php"><![CDATA[  function EditJSInfo($jt_id )
{
  CCPage::SetTitle('Edit Special User Info');

  $form = new JSJoesEditForm();

  if( empty($_POST['joesedit']) )
  {
    // this is first time we are displaying the form

    $show_form = true;
  }
  else
  {
    // we are in submit...

    $show_form = false;
  }

  if( $show_form )
  {
    // populate the form from a database

    $joestable =& JSJoesTable::GetTable();
    $values = $joestable->QueryKeyRow($jt_id);
    $form->PopulateValues($values);

    CCPage::AddForm( $form->GenerateForm() );
  }
} ]]></programlisting>

<para>You'll want to validate the fields first before you get the values. If the form
did not validate then ccHost automatically re-populates the data from the user's
input and marks the fields that did not validate, but you have to redisplay the form.
Here's what all that looks like:</para>

<programlisting role="php"><![CDATA[  function EditJSInfo($jt_id )
{
  CCPage::SetTitle('Edit Special User Info');

  $form = new JSJoesEditForm();

  if( empty($_POST['joesedit']) )
  {
    // this is first time we are displaying the form

    $show_form = true;

    // get the values from the database

    $need_values = true;
  }
  else
  {
    // we are in submit...

    if( $form->ValidateFields() )
    {
      // great, let's get the user's inputs...

      $form->GetFormValues($values);

      // process user values here...

      $joestable =& JSJoesTable::GetTable();
      $values['jt_id'] = $jt_id; // Update requires the key
      $joestable->Update($values);

      CCPage::Prompt("Your special information has been saved");

      $show_form = false;
    }
    else
    {
      // wups, have to show the form again
      // ccHost will display all the errors automatically

      $show_form = true;

      // do not populate the form from the database

      $need_values = false;

    }
  }

  if( $show_form )
  {
    if( $need_values )
    {
      // populate the form from a database

      $joestable =& JSJoesTable::GetTable();
      $values = $joestable->QueryKeyRow($jt_id);
      $form->PopulateValues($values);
    }

    CCPage::AddForm( $form->GenerateForm() );
  }
} ]]></programlisting>

<para>NOTE: The GetFormValues
method won't work at all until after you call ValidateFields so
you always have to call both to get the user values.</para>

</refsect2>

 <refsect2 id="{@id addfield}">
<title>Dynamically Insert a Form Field</title>

<para>You can dynamically add a field to an existing form (e.g. the user profile or
one of the upload forms). In order to do this you need to have an understanding
of how forms work in general ({@tutorial cchost.pkg#form.newform}).</para>
<para>Create a new module ({@tutorial cchost.pkg#modules.create}) and put the following lines at the top:</para>
<programlisting role="php"><![CDATA[  CCEvents::AddHandler(CC_EVENT_FORM_FIELDS,    array( 'myclass', 'OnFormFields'));
CCEvents::AddHandler(CC_EVENT_FORM_POPULATE,  array( 'myclass', 'OnFormPopulate') );
CCEvents::AddHandler(CC_EVENT_FORM_VERIFY,    array( 'myclass', 'OnFormVerify') );
 ]]></programlisting>
<para>Now create a class with those methods</para>
<programlisting role="php"><![CDATA[  class myclass
{
    function OnFormFields(&$form,&$fields)
    {
    }

    function OnFormPopulate(&$form,&$values)
    {
    }

    function OnFormVerify(&$form,&$isvalid)
    {
    }
}
 ]]></programlisting>
<para>Since your code will be called whenever a form is displayed you'll have
to check to see if it's the form you care about (in this case the form used
to edit user profile):</para>
<programlisting role="php"><![CDATA[  class myclass
{
    function OnFormFields(&$form,&$fields)
    {
        if( strtolower( get_class($form) ) != 'ccuserprofileform' )
          return;
    }

    function OnFormPopulate(&$form,&$values)
    {
        if( strtolower( get_class($form) ) != 'ccuserprofileform' )
          return;
    }


    function OnFormVerify(&$form,&$isvalid)
    {
        if( strtolower( get_class($form) ) != 'ccuserprofileform' )
          return;
    }
}
 ]]></programlisting>
<para>For each handler you can add the code required</para>
<programlisting role="php"><![CDATA[  class myclass
{
  // called when form object is being constructed

  function OnFormFields(&$form,&$fields)
  {
    if( strtolower( get_class($form) ) != 'ccuserprofileform' )
      return;

    // add our field into the form:

    $fields['jt_location'] =
          array( 'label'    => 'Location',
               'form_tip'   => 'Where are you?',
               'formatter'  => 'textedit',
               'flags'    => CCFF_NONE);
  }


  // called when form object is being displayed
  // for the first time

  function OnFormPopulate(&$form,&$values)
  {
    if( strtolower( get_class($form) ) != 'ccuserprofileform' )
      return;

    // do what you have to translate what's in $values
    // to a value the user expects...

    // look up the user's info in our table

    $joestable =& new JSJoesTable::GetTable();
    $where['jt_user'] = $values['user_id'];
    $location = $joestable->QueryItem('jt_location', $where);

    // now, set the value into the form:

    $form->SetFormValue('jt_location',$location);
  }


   called on form submit after the rest of the
  // form has validated (or not)


  function OnFormVerify(&$form,&$isvalid)
  {
    if( strtolower( get_class($form) ) != 'ccuserprofileform' )
      return;

    // this is the safe way to get a value from
    // the submitted form:

    $location = CCUtil::StripText($_POST['jt_location']);

    // do what you have to validate the data

    $isvalid_location = my_check_location_func($location);

    if( $isvalid_location )
    {
      // our data validated

      if( $isvalid )
      {
        // so did the rest of the form, let's save
        // our location data

        // get the user id from the form:

        $user_id = $form->GetFormValue( 'user_id' );

        // get an instance of our table

        $joestable =& new JSJoesTable::GetTable();

        // get the key for this user 
        // so we can do the update

        $args['jt_user'] = $user_id;
        $args['jt_id']   = $joestable->QueryKey($args);

        // save the data to the table

        $args['jt_location'] = $location;

        $joestable->Update($args);
      }
    }
    else
    {
      // our data did not validate,
      // tell the user why:

      $form->SetFieldError('jt_location',
            'The location must be on Earth');
    }

    $isvalid |= $isvalid_location;
  }
}
 ]]></programlisting>

</refsect2>
</refsect1>   <!----------------- END OF Forms -------------------->

<refsect1 id="{@id workhtml}">
<title>X/HTML</title>

    <para>
      <note>
          If you are totally unfamiliar with <ulink href="http://phptal.motion-twin.com/manual/en/#id2451458">PHPTAL</ulink>
          you will likely get pretty frustrated pretty fast.
      </note>
    </para>

<refsect2 id="{@id hackhtml}">
<title>Display HTML (Squirt)</title>

<para>{@tutorial cchost.pkg#modules.url Bind a URL} to a method and you can squirt directly into the page:</para>

<programlisting role="php"><![CDATA[  
function just_show_it()
{
    $html ='
<h3>Some hacked in HTML</h3>
<p>This will be in the client area.</p>
';

    CCPage::PageArg('body_html',$html,'show_body_html');
}
 ]]></programlisting>

    </refsect2>

    <refsect2 id="{@id viewfile}">
    <title>Display HTML (viewfile)</title>

          <para>
              Put an XML file into the <command>viewfile Path</command> and you can invoke php code from 
              within it. (See the {@tutorial admin.query.pkg#examples.templates admin Query tutorial} 
              for an example.) The advantage of this method is that you don't have to bind a new URL to
              see the results, just use the <filename>viewfile</filename> (a.k.a. <filename>docs</filename>) 
              command. The disadvantage is that
              this method is totally unsuitable for even mildly complex code.
          </para>

    </refsect2>

    <refsect2 id="{@id macro}">
    <title>Display HTML (Skin Macro)</title>

          <para>
            {@tutorial cchost.pkg#modules.url Bind a URL} to a method and invoke a macro that is known 
            to the current skin:
          </para>

<programlisting role="php"><![CDATA[  
function show_my_files($extra_tags='')
{
    if( !empty($extra_tags) )
        $extra_tags = ", $extra_tags";

    // retrieve the records...
    //
    require_once('cclib/cc-query.php');
    $query = new CCQuery();
    list( $records ) = $query->Query(array('f'=>'php','tags'=>"remix$exrra_tags"));

    // munge it with your special touch...
    //
    for( $i = 0; $i < count($records);
    {
        // do some custom special code with $record[$i] = 
    }

    // parameters:
    //    'records' -- this is the name of variable used in the template
    //                 the template expects this to be a specific thing
    //                 so you can't just make up a name
    //    $records  -- this is the data passed into the template
    //
    // 'list_files' -- this is the name of the template macro. The actual
    //                 location of the file is all handled by the 
    //                 template engine which knows about stuff like 
    //                 the current skin
    //
    CCPage::PageArg('records',$records,'list_files');
}
 ]]></programlisting>

</refsect2>

    <refsect2 id="{@id template}">
    <title>Display HTML (Custom Template Macro)</title>

    <para>
        Put an XML template with phpTAL <filename>metal:block</filename> macros into the <command>Skins Path</command>.
        {@tutorial cchost.pkg#modules.url Bind a URL} to a method and invoke those macros from PHP.
    </para>
<example><literal>
&lt;metal:block define-macro="my_macro" &gt;
    &lt;!-- local_files/skin/my_template.xml --&gt;
    &lt;select&gt;
       &lt;option repeat="record records" value="record/upload_id" &gt;
            ${record/upload_name}
       &lt;/option&gt;
    &lt;/select&gt;
&lt;/metal:block&gt;
</literal></example>

<programlisting role="php"><![CDATA[  
function use_my_template($extra_tags='')
{
    if( !empty($extra_tags) )
        $extra_tags = ", $extra_tags";

    // retrieve the records...
    //
    require_once('cclib/cc-query.php');
    $query = new CCQuery();
    list( $records ) = $query->Query(array('f'=>'php','tags'=>"remix$exrra_tags"));

    // Tell the skin where to find your macro
    //
    // This says: When I ask for 'some_name' I really
    // mean 'my_template.xml/my_macro'
    //
    CCPage::PageArg('some_name', 'my_template.xml/my_macro' );

    // This says: invoke the macro mapped to 'some_name'
    // passing in the data in $records and call it 
    // 'records'
    //
    CCPage::PageArg('records',$records,'list_files');
}
 ]]></programlisting>

    </refsect2>

    <refsect2 id="{@id query}">
    <title>Display HTML (For a Query)</title>

    <para>
      If the all you are listing out are upload records you definitely use the {@tutorial admin.query.pkg Query API} and a custom
      template. You don't need to bind any urls or write any PHP code at all to set that up. The admin docs have a 
      {@tutorial admin.tutnav.pkg example of how that works}.
    </para>
    </refsect2>

</refsect1> <!----------- END OF HTML ----------------------->

<refsect1 id="{@id ajax}">
<title>AJAX in ccHost</title>

    <para>ccHost uses <ulink href="http://google.com/search?prototype.js">prototype.js</ulink> "as is" on the
    client for AJAX requests.</para>
    <para>To return JSON use the Zend JSON encoder already included in ccHost</para>

    <refsect2 id="{@id json}">
    <title>Returning JSON</title>

<programlisting role="php"><![CDATA[  
{
    // setup data as native PHP
    //
    $return_vals = array( 'msg' => 'hello world' );

    // encode as JSON
    require_once('cclib/zend/json-encoder.php');
    $json =  CCZend_Json_Encoder::encode($return_vals);
  
    // JSON wants the data in the header
    header( "X-JSON: $text");
    header( 'Content-type: text/plain');
    print($text);

    // exit the session so nothing else gets printed
    exit;
}
 ]]></programlisting>

    </refsect2>

    <refsect2 id="{@id snippet}">
    <title>Returning HTML (Snippet)</title>
        <para>
          To return a snippet of HTML {@tutorial cchost.pkg#workhtml.template create a template macro} in your
          <command>Skins Path</command>. Then invoke it using the special {@link CCTemplateMacro} class.
        </para>

<example><literal>
&lt;metal:block define-macro="print_msg" &gt;
    &lt;!-- local_files/skin/my_template.xml --&gt;
    &lt;div class="message"&gt; ${args/msg} &lt;/div&gt;
&lt;/metal:block&gt;
</literal></example>

<programlisting role="php"><![CDATA[  
{
    // data to send into template
    //
    $args = array( 'msg' => 'hello world' );

    // Using this class you will have access to
    // all the current skins macros
    //
    $template = new CCTemplateMacro( 'my_template.xml', 'print_msg' );

    // This call presumes the macro is waiting for
    // a set a variables called 'args'
    // 
    $template->SetAllAndPrint('args',$args);

    // exit the session so nothing gets printed
    exit;
}
 ]]></programlisting>
    </refsect2>

    <refsect2 id="{@id skin}">
    <title>Returning HTML (Formatted Snippet)</title>
        <para>
          To return a snippet of HTML that has all the formatting and scripts of the current skin, 
          {@tutorial cchost.pkg#workhtml.template create a template macro} in your
          <command>Skins Path</command>. Then invoke it as did for 
          {@tutorial cchost.pkg#workhtml.macro placing a macro on a page} but call {@ CCPage::ShowHeaderFooter}
          with <literal>false,false</literal> to chop off the banner, menus and footers. This leaves 
          the &lt;head&gt; section of the skin in tact allowing you to enjoy the benefits of the style 
          sheets and javascript references of the current skin. The method is useful for popups. 
        </para>

<programlisting role="php"><![CDATA[  
function use_my_template($extra_tags='')
{
    if( !empty($extra_tags) )
        $extra_tags = ", $extra_tags";

    // retrieve the records...
    //
    require_once('cclib/cc-query.php');
    $query = new CCQuery();
    list( $records ) = $query->Query(array('f'=>'php','tags'=>"remix$exrra_tags"));

    // Tell the skin where to find your macro
    //
    // This says: When I ask for 'some_name' I really
    // mean 'my_template.xml/my_macro'
    //
    CCPage::PageArg('some_name', 'my_template.xml/my_macro' );

    // This says: invoke the macro mapped to 'some_name'
    // passing in the data in $records and call it 
    // 'records'
    //
    CCPage::PageArg('records',$records,'list_files');

    // We will print the page, but without 'adornments'
    //
    CCPage::ShowHeaderFooter(false,false);
}
 ]]></programlisting>

    </refsect2>


</refsect1> <!----------- END OF AJAX ----------------------->

<refsect1 id="{@id termstuff}">
<title>Terminology</title>

 <refsect2 id="{@id rowvsrecord}">
<title>"row" vs. "record"</title>

<para>The CCTable object has several methods with the word 'row' in it, QueryRows, QueryRow and QueryKeyRow. Whenever you see the word 'row' in the code it (almost) always refers to a
database table row as it is stored in the database (a.k.a the 'raw' data). Retrieving a row is generally
a very quick operation but the data in the row is of specialized, limited use.
</para>
<programlisting role="php"><![CDATA[  {
  $uploads =& CCUploads::GetTable();
  // get the upload with the upload_id of '101'
  $row = $uploads->QueryKeyRow(101); 
  $is_published = $row['upload_published'];
  $is_banned    = $row['upload_banned'];
} ]]></programlisting>
<para>Meanwhile a 'record' is a row that has been heavily massaged. Retrieving
the record is much more heavy weight operation but results in a lot more data that should have
just about everything you ever wanted to know about that upload, user, topic, etc. </para>
<programlisting role="php"><![CDATA[  {
  $uploads =& CCUploads::GetTable();
  // get the upload with the upload_id of '101'
  $record = $uploads->GetRecordFromKey(101); 
  $args['upload_href'] = $record['file_page_url'];
  $args['upload_text'] = $record['upload_name'];
  $args['user_href']   = $record['artist_page_url'];
  $args['user_text']   = $record['user_real_name'];
  //... ]]></programlisting>
<para>In order to get fully familiar with the what kind of data is available in both
rows and records, it is highly recommended that you set up a 
debug environment ({@tutorial cchost.pkg#debug}) and dump the contents using the GetRecordFromRow
method. First the row:</para>
<programlisting role="php"><![CDATA[  {
  $uploads =& CCUploads::GetTable();
  // get the upload with the upload_id of '101'
  $row = $uploads->QueryKeyRow(101); 
  CCDebug::PrintVar($row);
  //... ]]></programlisting>
<para>...then the record:</para>
<programlisting role="php"><![CDATA[  {
  $uploads =& CCUploads::GetTable();
  // get the upload with the upload_id of '101'
  $row = $uploads->QueryKeyRow(101); 
  $record =& $uploads->GetRecordFromRow($row);
  CCDebug::PrintVar($record);
  //... ]]></programlisting>
<para>If you determine that you really need the records and not the rows then you can
skip the conversion step and call GetRecords:</para>
<programlisting role="php"><![CDATA[  {
  $uploads =& CCUploads::GetTable();
  $where = "upload_name LIKE '%sunny%'";
  $records =& $uploads->GetRecords($where); // Returns an array
  // Don't use foreach with records, it's too expensive
  $count = count($records);
  for( $i = 0; $i < $count; $i++ )
  {
      $record =& $records[$i];
      //... ]]></programlisting>

</refsect2>

 <refsect2 id="{@id uploadvsfile}">
<title>"upload" vs "file"</title>

<para>An 'upload' is a database row that represents the meta information that the user
entered for their submission. It has the name, tags, description, etc. stored in it.
Use the CCUploads table object to access this data.</para>
<para>An upload can have more than one physical file stored on your server. Users upload
these files using the 'Manage Files' menu option on the upload's main page. Each file
has it's own specific meta data such as the file format, the physical
name, system tags, etc. The recommended way of accessing the specific data about a
file is through the files field of an upload 
record ({@tutorial cchost.pkg#termstuff.rowvsrecord}):</para>
<programlisting role="php"><![CDATA[  {
  $uploads =& CCUploads::GetTable();
  $where = "upload_name LIKE '%sunny%'";
  $records =& $uploads->GetRecords($where);
  $count = count($records);
  for( $i = 0; $i < $count; $i++ )
  {
      $record =& $records[$i];
      $files =& $record['files'];
      $fcount = count($files);
      for( $n = 0; $n < $fcount; $n++ )
      {
         $file =& $files[$n];
         //... ]]></programlisting>

<para>To get familiar with the contents of the file record you should set up a 
debug environment ({@tutorial cchost.pkg#debug}) to inspect the data:</para>
<programlisting role="php"><![CDATA[  {
  $uploads =& CCUploads::GetTable();
  $where = "upload_name LIKE '%sunny%'";
  $records =& $uploads->GetRecords($where);
  $count = count($records);
  for( $i = 0; $i < $count; $i++ )
  {
      $record =& $records[$i];
      CCDebug::PrintVar($record['files']);
      //... ]]></programlisting>


</refsect2>

 <refsect2 id="{@id uploadvsfile}">
<title>"key" vs "id"</title>

<para>The terms 'key' and 'id' are used interchangeably throughout ccHost code. They
both refer to the PRIMARY KEY column in any table which
are unique numeric references within the table. </para>

</refsect2>

</refsect1>

</refentry>
