<refentry id="{@id}">
 <refnamediv>
    <refname>ccHost - Developer Cookbook</refname>
    <refpurpose>A (hopefully) simple breakdown of common operations.</refpurpose>
 </refnamediv>
 {@toc}

 <refsect1 id="{@id debug}">
<title>Inspecting Variables (Debug)</title>

<para>In order to enable debugging on a development setup you should edit ./index.php
and change the line:</para>
<programlisting role="php"><![CDATA[  CCDebug::Enable(true); ]]></programlisting>
<para>Now you can inspect any
variable on the screen using CCDebug::PrintVar or in the log using CCDebug::LogVar or send any message to the log using CCDebug::Log. </para>
<para>CCDebug::PrintVar will stop execution at the point
it is called and display the variable in the browser. You can not pass a
constant, it must be a variable (or object or array, etc.) that can be a PHP reference.
HINT: If you want to inspect more than one variable at a time, put them into an array.
Some examples:</para>
<programlisting role="php"><![CDATA[  

function foo()
{
    CCDebug::PrintVar($_POST);
}

function bar()
{
    global $CC_GLOBALS;

    CCDebug::PrintVar($CC_GLOBALS);
}

function some_method_1($arg1, $arg2, $arg3 )
{
    // this will execute in any mode
    $value1 = $arg1 + 10;    

    // this will only work in debug mode
    CCDebug::PrintVar($value1);  

    // this will not execute in debug mode
    $value2 = $arg2 - 10;    
}

function some_method_2($arg1, $arg2, $arg3 )
{
    $x[] = $arg1;
    $x[] = $arg2;
    CCDebug::PrintVar($x);
}

function some_method_2($arg1 )
{
    // This won't work, the var must be a reference
    CCDebug::PrintVar('some arg: ' . $arg1);

    // this is fine
    $x = 'some arg: ' . $arg1;
    CCDebug::PrintVar($x);
}

function called_from_template($arg1)
{
    // if you are debugging code that is part of the
    // template display or called from a PHPTAL
    // template then you must specify
    // that the call is "not template safe"

    CCDebug::PrintVar($arg1, false);
}
 ]]></programlisting>
<para>CCDebug::LogVar and CCDebug::Log will
continue execution passed the point they are called and put the result into the log.(The log file is cc-log.txt and it's location depends on where you specified
during installation.)</para>
<programlisting role="php"><![CDATA[  function some_method_1($arg1, $arg2, $arg3 )
{
    // code will execute
    $value1 = $arg1 + 10; 

    CCDebug::LogVar('this is the value:', $value1);

    // so will this
    $value2 = $arg2 - 10; 
}

function some_method_2($arg1, $arg2, $arg3 )
{
    // code will execute
    $value1 = $arg1 + 10; 

    CCDebug::Log("I'm here at line " . __LINE__ );

    // so will this
    $value2 = $arg2 - 10; 
} ]]></programlisting>

</refsect1>

 <refsect1 id="{@id stacktrace}">
<title>Displaying a Stack Trace (Debug)</title>

<para>There's a lot of common code in ccHost and sometimes it's difficult
to figure out who is calling what in what context. If you're seeing an
error in common code make sure to 
turn on debug mode ({@tutorial cchost.pkg#debug})
and insert the following line where the error is occurring:</para>
<programlisting role="php"><![CDATA[  CCDebug::StackTrace(); ]]></programlisting>

</refsect1>

 <refsect1 id="{@id newmod}">
<title>Create a New Module</title>

<para>Create any file with .php extension and put
it into the ccextras directory. It will be
parsed and loaded on every session. All of the files from the cclib
directory will already be included in the name space so there is no need to include any
of them. If you depend on classes or defines from another file in the ccextras
directory you will need to use require_once('ccextras/file_with_base_class.php'); syntax at the top of the module. </para>

</refsect1>


 <refsect1 id="{@id url}">
<title>Create an URL and Bind it to a Method</title>

<para>At the top of the of a module ({@tutorial cchost.pkg#newmod}) put the following code:</para>
<programlisting role="php"><![CDATA[  
CCEvents::AddHandler( CC_EVENT_MAP_URLS, 
                      array( 'myclass', 'OnMapUrls' ) );
 ]]></programlisting>
<para>Create the class and a method to do the mapping:</para>
<programlisting role="php"><![CDATA[  class myclass
{
  function OnMapUrls()
  {
     CCEvents::MapUrl( ccp('some', 'url'),
             array( 'myclass', 'some_url_handler') ,
             CC_MUST_BE_LOGGED_IN
            );
  }
}
 ]]></programlisting>
<para>The last parameter is an access flag that must be one of the following:</para>
<programlisting role="php"><![CDATA[  CC_MUST_BE_LOGGED_IN
CC_ONLY_NOT_LOGGED_IN
CC_DONT_CARE_LOGGED_IN
CC_ADMIN_ONLY
 ]]></programlisting>
<para>Now create the method that will get called for that URL:</para>
<programlisting role="php"><![CDATA[  class myclass
{
  function some_url_handler()
  {
     // some random code:
     CCPage::SetTitle('Hello ccHost!');
     CCPage::Prompt("hello world!");
  }

  function OnMapUrls()
  {
     CCEvents::MapUrl( 
             ccp('some', 'url'),
             array( 'myclass', 'some_url_handler' ),
             CC_DONT_CARE_LOGGED_IN );
  }
}
 ]]></programlisting>
<para>You need to clear the URL and menu cache in order to register the new binding. In
your browser you should go to:</para>
<para>http://example.com/media/admin/menu/killcache</para>
<para>Now you are ready to test your new url-to-method binding. Browse to:</para>
<para>http://example.com/media/some/url</para>
<para>ccHost will call your method with any extra url parts after some/url. In order
to receive them you need add parameters to your handler method:</para>
<programlisting role="php"><![CDATA[  class myclass
{
  function some_url_handler($required, $optional='')
  {
     // some random code:
     CCPage::SetTitle('Hello $required!');
     if( empty($optional) )
       CCPage::Prompt("hello world!");
     else
       CCPage::Prompt("hello $optional!");
  }

  function OnMapUrls()
  {
     CCEvents::MapUrl( 
         ccp('some', 'url'), 
	 array( 'myclass', 'some_url_handler' ),
	 CC_DONT_CARE_LOGGED_IN );
  }
} ]]></programlisting>
<para>To see this action you can call any of the following urls:</para>
<para>http://example.com/media/some/url/cchost</para>
<para>http://example.com/media/some/url/cchost/mom</para>
<para>http://example.com/media/some/url/goodbye/marvin</para>
<para>You can hard wire a special case and bind it to another method:</para>
<programlisting role="php"><![CDATA[  class myclass
{
  function some_url_handler($required, $optional='')
  {
     // some random code:
     CCPage::SetTitle('Hello $required!');
     if( empty($optional) )
       CCPage::Prompt("hello world!");
     else
       CCPage::Prompt("hello $optional!");
  }

  function special_url_handler()
  {
     // some random code:
     CCPage::SetTitle('Special case');
     CCPage::Prompt("hello special case!");
  }

  function OnMapUrls()
  {
     CCEvents::MapUrl( 
      ccp('some', 'url'),
      array( 'myclass', 'some_url_handler' ),
      CC_DONT_CARE_LOGGED_IN);

     CCEvents::MapUrl( 
      ccp('some', 'url','special'),
      array( 'myclass', 'special_url_handler' ),
      CC_DONT_CARE_LOGGED_IN);
  }
} ]]></programlisting>
<para>In the case above, ccHost will route some/url/special to the
new method, and all other cases of some/url/* to the regular one.</para>
<para>DON'T FORGET to killcache every time you change URL mapping.</para>

</refsect1>

 <refsect1 id="{@id newcol}">
<title>Create a New Database Column</title>

<para>Here are the steps to add a new database column into an existing ccHost table.</para>
<para>First: create a file whose name is in the format: update_unique_part.inc and put that into ccextras directory.</para>
<para>For the unique_part you should use something that identifies you and a version number:</para>
<programlisting role="php"><![CDATA[  ccextras/update_joesoft_v_1_0.inc
ccextras/update_janeplugins_v_3_2a.inc ]]></programlisting>
<para>In that module create a class derived from CCUpdate
and implement the Update method that is named exactly the
same name as the unique_part of the file name:</para>
<programlisting role="php"><![CDATA[  // columns required by joesoft 

class joesoft_v_1_0 extends CCUpdate
{
    function Update()
    {
    }
} ]]></programlisting>
<para>Next you want to call the inherited _check_for_field() method. The prototype
is:</para>
<programlisting role="php"><![CDATA[  function _check_for_field( $table_name,
                                 $column_name,
                                 $column_description ) ]]></programlisting>
<para>Let's say you want to add an column for 'age' to the users table:</para>
<programlisting role="php"><![CDATA[  // columns required by joesoft 

class joesoft_v_1_0 extends CCUpdate
{
    function Update()
    {
        $this->_check_for_field(
                        'cc_tbl_user', 
                        'user_age', 
                        'INT(4) unsigned');
    }
} ]]></programlisting>
<para>Now whenever someone installs your plugin they will have to (logged in as admin) update
their site with by browsing to:</para>
<para>http://cchost_installation/?update=1</para>

</refsect1>

 <refsect1 id="{@id newtable}">
<title>Create a New Database Table</title>

<para>To add an entirely new table to a ccHost installation follow the same steps to 
Create a New Database Column ({@tutorial cchost.pkg#newcol}) 
except for the code in Update which will look something like this:</para>
<programlisting role="php"><![CDATA[  // table required by joesoft 

class joesoft_v_1_0 extends CCUpdate
{
  function Update()
  {
   $sql = '
    CREATE TABLE joes_table
    (
      jt_id    int(11) unsigned  NOT NULL auto_increment,
      jt_user  int(11) unsigned  NOT NULL,
      jt_age   int(4)  unsigned  NOT NULL,
      jt_allow_im  int(2)  unsigned  NOT NULL,
      jt_im    varchar(4) NOT NULL,
      jt_location  varchar(255) NOT NULL,

      PRIMARY KEY jt_id (jt_id)
    )
    ';

    CCDatabase::Query($sql);
  }
} ]]></programlisting>
<para>It is strongly suggested that you create a ccHost table wrapper for the class. After you
create a new module ({@tutorial cchost.pkg#newmod}) 
you should create a class derived from CCTable:</para>
<programlisting role="php"><![CDATA[  class JSJoesTable extends CCTable
{
  function JSJoesTable()
  {
     $this->CCTable( 'joes_table',  // mysql table name
             'jt_id'   // PRIMARY KEY
           );

  }

  // create a singleton factory
  function & GetTable()
  {
    static $_table;
    if( empty($_table) )
      $_table = new JSJoesTable();
    return $_table;
  }
} ]]></programlisting>

</refsect1>


 <refsect1 id="{@id insert}">
<title>Insert a Record Into a Table</title>

<para>All tables in the system follow the same code pattern for row insertion:</para>
<programlisting role="php"><![CDATA[  function AddUserAge($user_id, $age)
{
    $joestable =& JSJoesTable::GetTable();
    $args['jt_user'] = $user_id;
    $args['jt_age'] = $age;
    $joestable->Insert($args);
} ]]></programlisting>
<para>If you need to know the key of the new record use NextID:</para>
<programlisting role="php"><![CDATA[  function AddUserAge($user_id, $age)
{
    $joestable =& JSJoesTable::GetTable();
    $args['jt_id'] = $joestable->NextID();
    $args['jt_user'] = $user_id;
    $args['jt_age'] = $age;
    $joestable->Insert($args);
    return $args['jt_id'];
} ]]></programlisting>

</refsect1>


 <refsect1 id="{@id update}">
<title>Update a Database Record</title>

<para>All tables in the system follow the same code pattern for row updating. The
Update assumes that the argument array contains
a primary key (aka 'id') value:</para>
<programlisting role="php"><![CDATA[  function UpdateAge($jt_id, $age)
{
    $joestable =& JSJoesTable::GetTable();
    $args['jt_id'] = $jt_id;
    $args['jt_age'] = $age;
    $joestable->Update($args);
} ]]></programlisting>
<para>If you don't have the key you'll need to look it up:</para>
<programlisting role="php"><![CDATA[  function UpdateUserAge($user_id, $age)
{
    $joestable =& JSJoesTable::GetTable();
    $where['jt_user'] = $user_id;
    $jt_id = $joestable->QueryKey($where);
    UpdateAge($jt_id, $age);
}

function UpdateAge($jt_id, $age)
{
    $joestable =& JSJoesTable::GetTable();
    $args['jt_id'] = $jt_id;
    $args['jt_age'] = $age;
    $joestable->Update($args);
}
 ]]></programlisting>

</refsect1>


 <refsect1 id="{@id newform}">
<title>Display a Form</title>

<para>Create a class that derives that from CCForm. The name
of the class must in this specific form:</para>
<programlisting role="php"><![CDATA[  2-letter-prefix form_name Form (no spaces)

class CCJoesEditForm extends CCForm  // this is ok
class xxEditAgeForm  extends CCForm  // this is ok

class Joe   extends CCForm           // this is not
class xxJoe extends CCForm           // this is not ]]></programlisting>
<para>Fields are created in the constructor of the form object:</para>
<programlisting role="php"><![CDATA[  class JSJoesEditForm extends CCForm
{
  function JSJoesEditForm()
  {
    $this->CCForm();

    $fields = array(
       'age' => array(
          'label'   => 'Age',
          'form_tip'  => 'Enter your age here',
          'formatter' => 'textedit',
          'flags'   => CCFF_REQUIRED,
          ),
       'allow_im' => array(
          'label'   => 'Enable Instant Messaging',
          'form_tip'  => 'Enable instant messages notifications',
          'formatter' => 'checkbox',
          'flags'   => CCFF_NONE,
          ),
       'im' => array(
          'label'   => 'IM Service',
          'formatter' => 'select',
          'options'   => array(
                   'aol' => 'Americal Online',
                   'msn' => 'Microsoft',
                   'irc' => 'Independent Relay Crisis'
                   ),
          'flags'   => CCFF_NONE,
          ),
      );

    $this->AddFormFields($fields);
  }
} ]]></programlisting>
<para>A 'formatter' is the thing that generates the html for the field and
validates the value during submit. There are many standard and built in
generators. See cclib/cc-form.php for a list
functions that start with generator_ for the
standard ones. </para>
<para>The 'flags' field is very important and can lead to a lot of confusion
if used incorrectly. See the documentation AddFormFields
in cclib/cc-form.php for what is possible. All
flags begin with CCFF_ prefix.</para>
<para>To display your form:</para>
<programlisting role="php"><![CDATA[  function EditJSInfo()
{
    CCPage::SetTitle('Edit Special User Info');

    $form = new JSJoesEditForm();

    CCPage::AddForm( $form->GenerateForm() );
} ]]></programlisting>


</refsect1>



 <refsect1 id="{@id prepop}">
<title>Populate a Form</title>

<para>There are several ways to populate a form you've created ({@tutorial cchost.pkg#newform}). By
far the most efficient way is to use PopulateValues. In
order for PopulateValues to work you first have to mark
the fields you expect to populate with CCFF_POPULATE flag</para>
<programlisting role="php"><![CDATA[  'age' => array(
        'label'     => 'Age',
        'form_tip'  => 'Enter your age here',
        'formatter' => 'textedit',
        'flags'     => CCFF_REQUIRED | CCFF_POPULATE,
        ),
'allow_im' => array(
        'label'     => 'Enable Instant Messagings',
        'formatter' => 'checkbox',
        'flags'     => CCFF_POPULATE,
        ),
'im' => array(
    'label'     => 'IM Service',
    'formatter' => 'select',
    'options'   => array(
                     'aol' => 'Americal Online',
                     'msn' => 'Microsoft',
                     'irc' => 'Independent Relay Crisis'
                     ),
    'flags'     => CCFF_POPULATE,
    ),
 ]]></programlisting>
<para>Now you're ready to populate:</para>
<programlisting role="php"><![CDATA[  function EditJSInfo($age, $allow_im, $im )
{
    CCPage::SetTitle('Edit Special User Info');

    $form = new JSJoesEditForm();

    $values['age'] = $age;
    $values['allow_im'] = $allow_im;
    $values['im'] = $im;
    $form->PopulateValues($values);

    CCPage::AddForm( $form->GenerateForm() );
} ]]></programlisting>

<para>
HINT: If you are populating values from 
a database row ({@tutorial cchost.pkg#newtable}), then your life will get much
simpler if name the fields the same as the database columns:</para>
<programlisting role="php"><![CDATA[  class JSJoesEditForm extends CCForm
{
  function JSJoesEditForm()
  {
  $this->CCForm();

  $fields = array(
     'jt_age' => array(
      'label'   => 'Age',
      'form_tip'  => 'Enter your age here',
      'formatter' => 'textedit',
      'flags'   => CCFF_REQUIRED | CCFF_POPULATE,
      ),
     'jt_allow_im' => array(
      'label'   => 'Enable Instant Messagings',
      'formatter' => 'checkbox',
      'flags'   => CCFF_POPULATE,
      ),
     'jt_im' => array(
      'label'   => 'IM Service',
      'formatter' => 'select',
      'options'   => array(
           'aol' => 'Americal Online',
           'msn' => 'Microsoft',
           'irc' => 'Independent Relay Crisis'
           ),
      'flags'   => CCFF_POPULATE,
      ),
    );

  $this->AddFormFields($fields);
  }
} ]]></programlisting>

<para>Now the results of doing a query for a row can be used directly to populate the
form:</para>
<programlisting role="php"><![CDATA[  function EditJSInfo($jt_id )
{
    CCPage::SetTitle('Edit Special User Info');

    $form = new JSJoesEditForm();

    $joestable =& JSJoesTable::GetTable();
    $values = $joestable->QueryKeyRow($jt_id);
    $form->PopulateValues($values);

    CCPage::AddForm( $form->GenerateForm() );
} ]]></programlisting>

</refsect1>


 <refsect1 id="{@id submit}">
<title>Handling Form Submit</title>

<para>To handle a user submit of a form you've created ({@tutorial cchost.pkg#newform}) we'll
use the same method we use to populate the form ({@tutorial cchost.pkg#prepop}), only now
we'll check if we are processing the submit.</para>
<para>You can use the same URL to display the form initially and handle the
submit by mapping one URL ({@tutorial cchost.pkg#url}) to this method.</para>
<para>For (marginal) security reasons, the name of the form in lower case is in
PHP's $_POST array so you want to check for that to
see if you are in fact, process the submit:</para>
<programlisting role="php"><![CDATA[  function EditJSInfo($jt_id )
{
  CCPage::SetTitle('Edit Special User Info');

  $form = new JSJoesEditForm();

  if( empty($_POST['joesedit']) )
  {
    // this is first time we are displaying the form

    $show_form = true;
  }
  else
  {
    // we are in submit...

    $show_form = false;
  }

  if( $show_form )
  {
    // populate the form from a database

    $joestable =& JSJoesTable::GetTable();
    $values = $joestable->QueryKeyRow($jt_id);
    $form->PopulateValues($values);

    CCPage::AddForm( $form->GenerateForm() );
  }
} ]]></programlisting>

<para>You'll want to validate the fields first before you get the values. If the form
did not validate then ccHost automatically re-populates the data from the user's
input and marks the fields that did not validate, but you have to redisplay the form.
Here's what all that looks like:</para>

<programlisting role="php"><![CDATA[  function EditJSInfo($jt_id )
{
  CCPage::SetTitle('Edit Special User Info');

  $form = new JSJoesEditForm();

  if( empty($_POST['joesedit']) )
  {
    // this is first time we are displaying the form

    $show_form = true;

    // get the values from the database

    $need_values = true;
  }
  else
  {
    // we are in submit...

    if( $form->ValidateFields() )
    {
      // great, let's get the user's inputs...

      $form->GetFormValues($values);

      // process user values here...

      $joestable =& JSJoesTable::GetTable();
      $values['jt_id'] = $jt_id; // Update requires the key
      $joestable->Update($values);

      CCPage::Prompt("Your special information has been saved");

      $show_form = false;
    }
    else
    {
      // wups, have to show the form again
      // ccHost will display all the errors automatically

      $show_form = true;

      // do not populate the form from the database

      $need_values = false;

    }
  }

  if( $show_form )
  {
    if( $need_values )
    {
      // populate the form from a database

      $joestable =& JSJoesTable::GetTable();
      $values = $joestable->QueryKeyRow($jt_id);
      $form->PopulateValues($values);
    }

    CCPage::AddForm( $form->GenerateForm() );
  }
} ]]></programlisting>

<para>NOTE: The GetFormValues
method won't work at all until after you call ValidateFields so
you always have to call both to get the user values.</para>

</refsect1>

 <refsect1 id="{@id addfield}">
<title>Dynamically Insert a Form Field</title>

<para>You can dynamically add a field to an existing form (e.g. the user profile or
one of the upload forms). In order to do this you need to have an understanding
of how forms work in general ({@tutorial cchost.pkg#newform}).</para>
<para>Create a new module ({@tutorial cchost.pkg#newmod}) and put the following lines at the top:</para>
<programlisting role="php"><![CDATA[  CCEvents::AddHandler(CC_EVENT_FORM_FIELDS,    array( 'myclass', 'OnFormFields'));
CCEvents::AddHandler(CC_EVENT_FORM_POPULATE,  array( 'myclass', 'OnFormPopulate') );
CCEvents::AddHandler(CC_EVENT_FORM_VERIFY,    array( 'myclass', 'OnFormVerify') );
 ]]></programlisting>
<para>Now create a class with those methods</para>
<programlisting role="php"><![CDATA[  class myclass
{
    function OnFormFields(&$form,&$fields)
    {
    }

    function OnFormPopulate(&$form,&$values)
    {
    }

    function OnFormVerify(&$form,&$isvalid)
    {
    }
}
 ]]></programlisting>
<para>Since your code will be called whenever a form is displayed you'll have
to check to see if it's the form you care about (in this case the form used
to edit user profile):</para>
<programlisting role="php"><![CDATA[  class myclass
{
    function OnFormFields(&$form,&$fields)
    {
        if( strtolower( get_class($form) ) != 'ccuserprofileform' )
          return;
    }

    function OnFormPopulate(&$form,&$values)
    {
        if( strtolower( get_class($form) ) != 'ccuserprofileform' )
          return;
    }


    function OnFormVerify(&$form,&$isvalid)
    {
        if( strtolower( get_class($form) ) != 'ccuserprofileform' )
          return;
    }
}
 ]]></programlisting>
<para>For each handler you can add the code required</para>
<programlisting role="php"><![CDATA[  class myclass
{
  // called when form object is being constructed

  function OnFormFields(&$form,&$fields)
  {
    if( strtolower( get_class($form) ) != 'ccuserprofileform' )
      return;

    // add our field into the form:

    $fields['jt_location'] =
          array( 'label'    => 'Location',
               'form_tip'   => 'Where are you?',
               'formatter'  => 'textedit',
               'flags'    => CCFF_NONE);
  }


  // called when form object is being displayed
  // for the first time

  function OnFormPopulate(&$form,&$values)
  {
    if( strtolower( get_class($form) ) != 'ccuserprofileform' )
      return;

    // do what you have to translate what's in $values
    // to a value the user expects...

    // look up the user's info in our table

    $joestable =& new JSJoesTable::GetTable();
    $where['jt_user'] = $values['user_id'];
    $location = $joestable->QueryItem('jt_location', $where);

    // now, set the value into the form:

    $form->SetFormValue('jt_location',$location);
  }


   called on form submit after the rest of the
  // form has validated (or not)


  function OnFormVerify(&$form,&$isvalid)
  {
    if( strtolower( get_class($form) ) != 'ccuserprofileform' )
      return;

    // this is the safe way to get a value from
    // the submitted form:

    $location = CCUtil::StripText($_POST['jt_location']);

    // do what you have to validate the data

    $isvalid_location = my_check_location_func($location);

    if( $isvalid_location )
    {
      // our data validated

      if( $isvalid )
      {
        // so did the rest of the form, let's save
        // our location data

        // get the user id from the form:

        $user_id = $form->GetFormValue( 'user_id' );

        // get an instance of our table

        $joestable =& new JSJoesTable::GetTable();

        // get the key for this user 
        // so we can do the update

        $args['jt_user'] = $user_id;
        $args['jt_id']   = $joestable->QueryKey($args);

        // save the data to the table

        $args['jt_location'] = $location;

        $joestable->Update($args);
      }
    }
    else
    {
      // our data did not validate,
      // tell the user why:

      $form->SetFieldError('jt_location',
            'The location must be on Earth');
    }

    $isvalid |= $isvalid_location;
  }
}
 ]]></programlisting>

</refsect1>

 <refsect1 id="{@id hackhtml}">
<title>Display HTML (Hack)</title>

<para>If want to just hack in some HTML into page (not recommended, although understandable
during development). If have you haven't already, you first need to
create a module ({@tutorial cchost.pkg#newmod}) and bind a unique URL ({@tutorial cchost.pkg#url}). Then in the method that it's bound to do the following:</para>
<programlisting role="php"><![CDATA[  
function just_show_it()
{
    $html ='
<h3>Some hacked in HTML</h3>
<p>This will be in the client area.</p>
';

    CCPage::PageArg('body_html',$html,'show_body_html');
}
 ]]></programlisting>

</refsect1>

 <refsect1 id="{@id indhtml}">
<title>Display HTML (Special Case)</title>

<para>Often you have HTML that is not reusable in a general sense and is
extremely unlikely to be replaced by template writers. Typically these
are admin displays, but may in rare cases, involve end user scenarios.</para>
<para>The upside of doing things this way is that you don't have to change
any of the skin template files and force users to update the <filename>skins</filename>
directory. The downside is that skin authors will not be able to fully incorporate your
display with their skin and it's far less flexible to customize.
</para>
<para>If you totally unfamiliar with <a href="http://phptal.motion-twin.com/manual/en/#id2451458">PHPTAL</a>
you will likely get pretty frustrated pretty fast.</para>
<para>The downside is that you have to jump through some hoops to get some of
the same macros and functionality available in the skin template system.</para>
<para>In all cases you will need to create a module ({@tutorial cchost.pkg#newmod}).</para>
<h3>Method 1: Pull data into an XML template</h3>
<para>This is the absolute easiest way to create templatized HTML in ccHost.
Put code into your module that returns a record set or other relevant data:</para>
<programlisting role="php"><![CDATA[  function js_get_records($limit)
{
    // Get an instance of our table

    $joestable =& new JSJoesTable::GetTable();
    $joestable->SetOffsetAndLimit(0,$limit);
    $rows = $joestable->QueryRows('');
    return $rows;
}
 ]]></programlisting>
<para>Now create an XML file and place it into ccfiles directory. (We'll
call ours ccfiles/jtinfo.xml.) The first thing you want to do is
pull the data into the template:</para>
<programlisting role="php"><![CDATA[  <div>
  <h1>My Joe Data</h1>
  <tal:block define="jsdata php:js_get_records('10');" />
</div>
 ]]></programlisting>
<para>Once that's done you can iterate over the records displaying the contents:</para>
<programlisting role="php"><![CDATA[  <div>
  <h1>My Joe Data</h1>
  <tal:block define="jsdata php:js_get_records('10');" />
  <table>
    <tr tal:repeat="item jsdata">
      <td>${item/jt_user}</td>
      <td>${item/jt_location}</td>
      <td>${item/jt_im}</td>
    </tr>
   </table>
</div>
 ]]></programlisting>
<para>Use the 'viewfile' url to see the results</para>
<para>http://your_install/media/viewfile/jtinfo.xml</para>
<para>In case you think this is 'low rent' many features at ccMixter (picks, charts,
radio, etc.) are done using this method.</para>
<h3>Method 2: Use a template to inject HTML onto page</h3>
<para>In this method, you'll set up the data, create an instance of the template in
code and merge the two, then display it as HTML.</para>

<para>Create a template XML file and put it in ccfiles
(or ccextras if you like).</para>
<para>In this file you can simple refer to template variables that will 'magically'
be there when we do the merge:</para>
<programlisting role="php"><![CDATA[  <div>

   <tal:block define="is_logged_in logged_in_as | 0" />

   <div tal:condition="is_logged_in">Hello ${user_real_name}!</div>

   <div>There are ${jscount} records here...</div>

   <table>
    <tr tal:repeat="item jsrows">
      <td>${item/jt_user}</td>
      <td>${item/jt_location}</td>
      <td>${item/jt_im}</td>
    </tr>
   </table>
</div> ]]></programlisting>
<para>After you create a module ({@tutorial cchost.pkg#newmod}) and 
bind a URL to a method ({@tutorial cchost.pkg#url}) you want to set up the data to pass to the template:</para>
<programlisting role="php"><![CDATA[  class myclass
{
  function ShowJSRecords()
  {
    global $CC_GLOBALS;

    CCPage::SetTitle('Show Joe Records');

    // Get an instance of  our table

    $joestable =& new JSJoesTable::GetTable();

    // start with the current set of globals

    $args = $CC_GLOBALS;

    // now get some custom data together:

    $args['jsrows'] = $joestable->QueryRows('');
    $args['jscount'] = count($args['jsrows']);


    // now instantiate a template pointing to our xml

    $template = new CCTemplate( 'ccextras/jstemplate.xml' );

    // do the merge

    $html = $template->SetAllAndParse($args);

    // now add the result to the current page

    CCPage::PageArg('body_html',$html,'show_body_html');

  }

} ]]></programlisting>

</refsect1>

 <refsect1 id="{@id template}">
<title>Display HTML (Official)</title>

<para>Using the 'proper' way to display HTML will ensure that your HTML will conform
to the skins engine and can be over ridden by skin authors who may may want
to customize it. If these are not concerns for you then you might consider the 
'special case' ({@tutorial cchost.pkg#indhtml}) method of displaying HTML.</para>
<para>The basic steps in this method:
<ol><li>Create a new template file and put it into <filename>skins</filename> directory (e.g.
fancy.xml).
</li>
<li>Create a new template macro using the metal-macro syntax:
<programlisting role="php"><![CDATA[  <metal:block define-macro="fancy_macro">
  <div class="fancy_div">
     Hello, this is my ${fancy_data/msg}
  </div>
</metal:block>
 ]]></programlisting>
<ul><li>Optional: If you have specific styles you should not put them into the
template macro, instead you should put them at the end of the skins/skin-yourskin.css.<br />
<programlisting role="php"><![CDATA[  .fancy_div {
  font-size: 14px;
  color: green;
} ]]></programlisting>
<br /></li></ul>
</li>
<li>Map the name of your new macro so it can be over ridden (redirected) in the future. Do
this is skins/skin-yourskin-map.xml:
<programlisting role="php"><![CDATA[  <tal:block define="
    fancy_html string:fancy.xml/fancy_html;
    ...
    " >
 ]]></programlisting>
</li>
<li>Now you're ready to refer to the re-directed name in your PHP code. (Now would be a good time
to create a module ({@tutorial cchost.pkg#newmod}) and 
set up a bound URL ({@tutorial cchost.pkg#url}).) You'll use
the CCPage::PageArg method to call your macro and merge variables.
<programlisting role="php"><![CDATA[  function show_fancy_html()
{
   $args['msg'] = 'very, very fancy message';

   CCPage::PageArg( 
      'fancy_data', // name of variables as 
                    // seen in template macro  
       $args,        // data passed into template
       'fancy_macro' // name of template macro  
     );
} ]]></programlisting></li></ol>
</para>

</refsect1>

 <refsect1 id="{@id testbed}">
<title>Create a Quick Test Bed (debug)</title>

<para>Sometimes you just want to see if your 'stuff' will work at all. To create a quick
and dirty test bed start by creating a module ({@tutorial cchost.pkg#newmod}) and put the following
at the top:</para>
<programlisting role="php"><![CDATA[  CCEvents::AddHandler(CC_EVENT_APP_INIT,  'just_testing' );

function just_testing()
{
} ]]></programlisting>
<para>Now this method will be called each and every time a page is hit on your
site. The good new is that the entire ccHost is up and running at this
point, so you can try just about any code you like. It is strongly suggested
that you test for a specific query string so you don't run your code all
the time:</para>
<programlisting role="php"><![CDATA[  CCEvents::AddHandler(CC_EVENT_APP_INIT,  'just_testing' );

function just_testing()
{
    if( empty($_GET['test']) )
        return;

} ]]></programlisting>
<para>If you are running on a public site you definitely want to (at least)
check if it's an admin:</para>
<programlisting role="php"><![CDATA[  CCEvents::AddHandler(CC_EVENT_APP_INIT,  'just_testing' );

function just_testing()
{
    if( empty($_GET['test']) || !CCUser::IsAdmin()))
        return;

} ]]></programlisting>
<para>At this point you can try your luck at some code:</para>
<programlisting role="php"><![CDATA[  CCEvents::AddHandler(CC_EVENT_APP_INIT,  'just_testing' );

function just_testing()
{
  if( empty($_GET['test']) || !CCUser::IsAdmin()))
    return;

  $uploads =& CCUploads::GetTable();
  $uploads->SetTagFilter('remix');
  $rows = $uploads->QueryRows('');
  $count = count($rows);
  for( $i = 0; $i < $count; ++$i )
  {
    if( strpos($rows[$i]['upload_name'],'dirtyword')
          !== false )
    {
       print("dirtyword found in: " 
        . $rows[$i]['upload_name'] );
    }
  }

  exit;

} ]]></programlisting>
<para>To invoke your test bed browse to:</para>
<para>http://your_cchost_install/?test=1</para>

</refsect1>

 <refsect1 id="{@id rowvsrecord}">
<title>"row" vs. "record"</title>

<para>The CCTable object has several methods with the word 'row' in it, QueryRows, QueryRow and QueryKeyRow. Whenever you see the word 'row' in the code it (almost) always refers to a
database table row as it is stored in the database (a.k.a the 'raw' data). Retrieving a row is generally
a very quick operation but the data in the row is of specialized, limited use.
</para>
<programlisting role="php"><![CDATA[  {
  $uploads =& CCUploads::GetTable();
  // get the upload with the upload_id of '101'
  $row = $uploads->QueryKeyRow(101); 
  $is_published = $row['upload_published'];
  $is_banned    = $row['upload_banned'];
} ]]></programlisting>
<para>Meanwhile a 'record' is a row that has been heavily massaged. Retrieving
the record is much more heavy weight operation but results in a lot more data that should have
just about everything you ever wanted to know about that upload, user, topic, etc. </para>
<programlisting role="php"><![CDATA[  {
  $uploads =& CCUploads::GetTable();
  // get the upload with the upload_id of '101'
  $record = $uploads->GetRecordFromKey(101); 
  $args['upload_href'] = $record['file_page_url'];
  $args['upload_text'] = $record['upload_name'];
  $args['user_href']   = $record['artist_page_url'];
  $args['user_text']   = $record['user_real_name'];
  //... ]]></programlisting>
<para>In order to get fully familiar with the what kind of data is available in both
rows and records, it is highly recommended that you set up a 
debug environment ({@tutorial cchost.pkg#debug}) and dump the contents using the GetRecordFromRow
method. First the row:</para>
<programlisting role="php"><![CDATA[  {
  $uploads =& CCUploads::GetTable();
  // get the upload with the upload_id of '101'
  $row = $uploads->QueryKeyRow(101); 
  CCDebug::PrintVar($row);
  //... ]]></programlisting>
<para>...then the record:</para>
<programlisting role="php"><![CDATA[  {
  $uploads =& CCUploads::GetTable();
  // get the upload with the upload_id of '101'
  $row = $uploads->QueryKeyRow(101); 
  $record =& $uploads->GetRecordFromRow($row);
  CCDebug::PrintVar($record);
  //... ]]></programlisting>
<para>If you determine that you really need the records and not the rows then you can
skip the conversion step and call GetRecords:</para>
<programlisting role="php"><![CDATA[  {
  $uploads =& CCUploads::GetTable();
  $where = "upload_name LIKE '%sunny%'";
  $records =& $uploads->GetRecords($where); // Returns an array
  // Don't use foreach with records, it's too expensive
  $count = count($records);
  for( $i = 0; $i < $count; $i++ )
  {
      $record =& $records[$i];
      //... ]]></programlisting>

</refsect1>

 <refsect1 id="{@id uploadvsfile}">
<title>"upload" vs "file"</title>

<para>An 'upload' is a database row that represents the meta information that the user
entered for their submission. It has the name, tags, description, etc. stored in it.
Use the CCUploads table object to access this data.</para>
<para>An upload can have more than one physical file stored on your server. Users upload
these files using the 'Manage Files' menu option on the upload's main page. Each file
has it's own specific meta data such as the file format, the physical
name, system tags, etc. The recommended way of accessing the specific data about a
file is through the files field of an upload 
record ({@tutorial cchost.pkg#rowvsrecord}):</para>
<programlisting role="php"><![CDATA[  {
  $uploads =& CCUploads::GetTable();
  $where = "upload_name LIKE '%sunny%'";
  $records =& $uploads->GetRecords($where);
  $count = count($records);
  for( $i = 0; $i < $count; $i++ )
  {
      $record =& $records[$i];
      $files =& $record['files'];
      $fcount = count($files);
      for( $n = 0; $n < $fcount; $n++ )
      {
         $file =& $files[$n];
         //... ]]></programlisting>

<para>To get familiar with the contents of the file record you should set up a 
debug environment ({@tutorial cchost.pkg#debug}) to inspect the data:</para>
<programlisting role="php"><![CDATA[  {
  $uploads =& CCUploads::GetTable();
  $where = "upload_name LIKE '%sunny%'";
  $records =& $uploads->GetRecords($where);
  $count = count($records);
  for( $i = 0; $i < $count; $i++ )
  {
      $record =& $records[$i];
      CCDebug::PrintVar($record['files']);
      //... ]]></programlisting>


</refsect1>

 <refsect1 id="{@id uploadvsfile}">
<title>"key" vs "id"</title>

<para>The terms 'key' and 'id' are used interchangeably throughout ccHost code. They
both refer to the PRIMARY KEY column in any table which
are unique numeric references within the table. </para>

</refsect1>

 <refsect1 id="{@id uploadextra}">
<title>Adding Custom Data To Upload Records</title>

<para>You can add custom data to any upload record without changing the database meta data (adding
tables or columns). The upload_extra field in each 
upload record ({@tutorial cchost.pkg#rowvsrecord}) designed specifically
to hold this kind of custom data. There is also a simple API for setting and getting your
data.</para>
<h3>To Add Your Custom Data</h3>
<programlisting role="php"><![CDATA[  function add_my_data($my_data,$upload_id)
{
  $uploads =& CCUploads::GetTable();
  $uploads->SetExtraField(
     $upload_id,    // This can also be a reference
                    // to a record  
     'joes_extra',  // The name of your extra field  
     $my_data       // This can be any serializeable type
                    // of data including array.
   );
} ]]></programlisting>

<h3>To Retrieve Your Custom Data</h3>
<programlisting role="php"><![CDATA[  function get_my_data($upload_id)
{
  $uploads =& CCUploads::GetTable();
  return $uploads->GetExtraField($upload_id, 'joes_extra');
} ]]></programlisting>

<para>Alternatively, if you are already looking at a record, you can access the data directly:</para>
<programlisting role="php"><![CDATA[  function get_my_data_from_record(&$record)
{
  if( exist( $record['upload_extra']['joes_extra'] ) )
     return $record['upload_extra']['joes_extra'];
  return null;
} ]]></programlisting>

<h3>To Search For Your Custom Data</h3>
<para>The only drawback to using this method is that searching for your data is extremely expensive
(it takes a long time) and is strongly recommended you don't do it. See the documentation for
CCUploads::WhereForSerializedField if you really must or if
searching on this data is critical then you should probably consider adding a 
new column ({@tutorial cchost.pkg#newcol}) to cc_tbl_uploads or even better, a 
new table ({@tutorial cchost.pkg#newtable}) instead using 
the extra field.</para>
<para>If you can get by with just searching for records with presence of your extra
data then you can add a system tag to the upload row when you add the data:</para>
<programlisting role="php"><![CDATA[  function add_my_data($my_data,$upload_id)
{
  $uploads =& CCUploads::GetTable();
  $uploads->SetExtraField($upload_id,
                          'joes_extra',
                          $my_data
                          );

  // A terrible name for a useful function:
  // this call will add a tag 'joes_data'
  CCUploadAPI::UpdateCCUD($upload_id,'joes_tag','');

} ]]></programlisting>
<para>Now it's just a matter of setting a tag filter to limit results that have your custom
data in the extra fields:</para>
<programlisting role="php"><![CDATA[  function list_recs_with_joes_data()
{
  $uploads =& CCUploads::GetTable();

  // Filter results with this tag
  $uploads->SetTagFilter('joes_tag');    
  
  // Empty 'where' gets all tagged records
  $records =& $uploads->GetRecords(''); 
  
  // Don't forget to release the tag filter (!!!)
  $uploads->SetTagFilter('');            
  
  // $records now points to all uploads with our data
  $count = count($records);              
  for( $i = 0; $i < $count; $i++)
  {
    $record =& $records[$i];
    $joes_data = $record['upload_extra']['joes_data'];
    //.... ]]></programlisting>
<h3>Editing and Deleting Your Custom Data</h3>
<para>Editing and deleting the data has some non-obvious implications whether you use
the tagging method above or not. This method puts some of the basics together:</para>
<programlisting role="php"><![CDATA[  function update_extra_data($upload_id, $my_data)
{
  $uploads =& CCUploads::GetTable();

  // let's see what's currently there: 

  $current_data = $uploads->GetExtraField($upload_id,'joes_data');

  if( empty($my_data) )
  {
    // delete the tag:

    CCUploadAPI::UpdateCCUD($upload_id,'','joes_tag');

    if( !empty($current_data) )
    {
      // something is there now, let's clear it:

      $uploads->SetExtraField($upload_id,'joes_data','');
    }
  }
  else
  {
    // do we need to add a tag? 

    if( empty($current_data) )
      CCUploadAPI::UpdateCCUD($upload_id,'joes_tag','');  // yup

    // set the extra data 
    $uploads->SetExtraField($upload_id,'joes_data',$my_data);

  }
} ]]></programlisting>
</refsect1>

</refentry>
